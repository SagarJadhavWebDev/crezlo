{"version":3,"file":"index.esm.js","sources":["../../src/constants/env.constants.ts","../../src/utils/cookieManager.ts","../../src/utils/auth.utils.ts","../../src/utils/apiClient.ts","../../src/utils/apiInstance.ts","../../src/utils/fileUpload.utils.tsx","../../src/constants/api-endpoints.constants.ts","../../src/context-providers/AuthProvider.tsx","../../src/utils/getSubDomain.ts","../../src/context-providers/AppProvider.tsx"],"sourcesContent":["const APP_HTTP = process.env.NODE_ENV === \"production\" ? \"https://\" : \"http://\";\r\nconst APP_DOMAIN = process.env.NEXT_PUBLIC_APP_DOMAIN;\r\nconst ACCOUNT = process.env.NEXT_PUBLIC_APP_URL_ACCOUNT || \"accounts\";\r\nconst FINANCE = process.env.NEXT_PUBLIC_APP_URL_FINANCE || \"finance\";\r\nconst VR = process.env.NEXT_PUBLIC_APP_URL_VR || \"virtualtour\";\r\nconst COMMUNITY = process.env.NEXT_PUBLIC_APP_URL_COMMUNITY || \"community\";\r\nconst WEBSITE = process.env.NEXT_PUBLIC_APP_URL_WEBSITE || \"website\";\r\nconst GENAGENT = process.env.NEXT_PUBLIC_APP_URL_GENAGENT || \"genagent\";\r\nexport const envConstants = {\r\n  APP_DOMAIN: process.env.NODE_ENV === \"production\" ? APP_DOMAIN : \"crezlo.local\",\r\n  APP_NAME: {\r\n    ACCOUNT: ACCOUNT,\r\n    FINANCE: FINANCE,\r\n    VR: VR,\r\n    COMMUNITY: COMMUNITY,\r\n    WEBSITE: WEBSITE,\r\n    GENAGENT: GENAGENT,\r\n  },\r\n  APP_URL: {\r\n    ACCOUNT: `${APP_HTTP}${ACCOUNT}.${APP_DOMAIN}`,\r\n    FINANCE: `${APP_HTTP}${FINANCE}.${APP_DOMAIN}`,\r\n    VR: `${APP_HTTP}${VR}.${APP_DOMAIN}`,\r\n    COMMUNITY: `${APP_HTTP}${COMMUNITY}.${APP_DOMAIN}`,\r\n    WEBSITE: `${APP_HTTP}${WEBSITE}.${APP_DOMAIN}`,\r\n    GENAGENT: `${APP_HTTP}${GENAGENT}.${APP_DOMAIN}`,\r\n  },\r\n  SUBSCRIPTION_TYPE: process.env.NEXT_PUBLIC_SUBSCRIPTION_TYPE,\r\n  BASE_API_URL: {\r\n    CORE: process.env.NEXT_PUBLIC_API_URL_CORE,\r\n    CONTENT: process.env.NEXT_PUBLIC_API_URL_CONTENT,\r\n    CHAT: process.env.NEXT_PUBLIC_API_URL_CHAT,\r\n    GENAGENT: process.env.NEXT_PUBLIC_API_GENAGENT_URL,\r\n    WEBSITE_BUILDER: process.env.NEXT_PUBLIC_WEBSITE_BUILDER_URL,\r\n    CHANNEL_BUILDER: process.env.NEXT_PUBLIC_CHANNEL_BUILDERL_URL,\r\n    FINANCE: process.env.NEXT_PUBLIC_FINANCE_URL,\r\n  },\r\n};\r\n","import { envConstants } from \"../constants\";\r\n\r\nexport interface CookieOptions {\r\n  expires?: Date | number; // Date object or days from now\r\n  maxAge?: number; // seconds\r\n  domain?: string;\r\n  path?: string;\r\n  secure?: boolean;\r\n  httpOnly?: boolean;\r\n  sameSite?: \"strict\" | \"lax\" | \"none\";\r\n}\r\n\r\nexport interface CookieManagerConfig {\r\n  defaultPath?: string;\r\n  defaultDomain?: string;\r\n  defaultSecure?: boolean;\r\n  defaultSameSite?: \"strict\" | \"lax\" | \"none\";\r\n  prefix?: string; // Prefix for all cookie names\r\n}\r\n\r\nexport class CookieManager {\r\n  private config: CookieManagerConfig;\r\n\r\n  constructor(config: CookieManagerConfig = {}) {\r\n    this.config = {\r\n      defaultPath: \"/\",\r\n      defaultSecure: typeof window !== \"undefined\" ? window.location.protocol === \"https:\" : false,\r\n      defaultDomain: `.${envConstants.APP_DOMAIN}`,\r\n      ...config,\r\n    };\r\n  }\r\n\r\n  // Set a cookie\r\n  set(name: string, value: string, options: CookieOptions = { expires: 1000 }): boolean {\r\n    if (typeof document === \"undefined\") {\r\n      console.warn(\"CookieManager: document is not available (SSR environment)\");\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const cookieName = this.config.prefix ? `${this.config.prefix}${name}` : name;\r\n      let cookieString = `${encodeURIComponent(cookieName)}=${encodeURIComponent(value)}`;\r\n\r\n      // Handle expires\r\n      if (options.expires) {\r\n        if (typeof options.expires === \"number\") {\r\n          // Convert days to date\r\n          const date = new Date();\r\n          date.setTime(date.getTime() + options.expires * 24 * 60 * 60 * 1000);\r\n          cookieString += `; expires=${date.toUTCString()}`;\r\n        } else {\r\n          cookieString += `; expires=${options.expires.toUTCString()}`;\r\n        }\r\n      }\r\n\r\n      // Handle maxAge\r\n      if (options.maxAge !== undefined) {\r\n        cookieString += `; max-age=${options.maxAge}`;\r\n      }\r\n\r\n      // Handle path\r\n      const path = options.path ?? this.config.defaultPath;\r\n      if (path) {\r\n        cookieString += `; path=${path}`;\r\n      }\r\n\r\n      // Handle domain\r\n      const domain = options.domain ?? this.config.defaultDomain;\r\n      if (domain) {\r\n        cookieString += `; domain=${domain}`;\r\n      }\r\n\r\n      // Handle secure\r\n      const secure = options.secure ?? this.config.defaultSecure;\r\n      if (secure) {\r\n        cookieString += \"; secure\";\r\n      }\r\n\r\n      // Handle httpOnly (note: this can't be set via JavaScript)\r\n      if (options.httpOnly) {\r\n        console.warn(\"CookieManager: httpOnly flag cannot be set via JavaScript\");\r\n      }\r\n\r\n      // Handle sameSite\r\n      const sameSite = options.sameSite ?? this.config.defaultSameSite;\r\n      if (sameSite) {\r\n        cookieString += `; samesite=${sameSite}`;\r\n      }\r\n      console.log(\"Setting cookie:\", cookieString);\r\n      document.cookie = cookieString;\r\n      return true;\r\n    } catch (error) {\r\n      console.error(\"CookieManager: Error setting cookie:\", error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Get a cookie value\r\n  get(name: string): string | null {\r\n    if (typeof document === \"undefined\") {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const cookieName = this.config.prefix ? `${this.config.prefix}${name}` : name;\r\n      const encodedName = encodeURIComponent(cookieName);\r\n      const cookies = document.cookie.split(\";\");\r\n\r\n      for (let cookie of cookies) {\r\n        cookie = cookie.trim();\r\n        if (cookie.startsWith(`${encodedName}=`)) {\r\n          return decodeURIComponent(cookie.substring(encodedName.length + 1));\r\n        }\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error(\"CookieManager: Error getting cookie\", error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Get a cookie value and parse as JSON\r\n  getJSON<T = any>(name: string): T | null {\r\n    const value = this.get(name);\r\n    if (value === null) return null;\r\n\r\n    try {\r\n      return JSON.parse(value);\r\n    } catch (error) {\r\n      console.error(\"CookieManager: Error parsing JSON cookie\", error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Set a cookie with JSON value\r\n  setJSON(name: string, value: any, options: CookieOptions = {}): boolean {\r\n    try {\r\n      const jsonString = JSON.stringify(value);\r\n      return this.set(name, jsonString, options);\r\n    } catch (error) {\r\n      console.error(\"CookieManager: Error stringifying JSON cookie\", error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Remove a cookie\r\n  remove(name: string, options: Pick<CookieOptions, \"path\" | \"domain\"> = {}): boolean {\r\n    return this.set(name, \"\", {\r\n      ...options,\r\n      expires: new Date(0), // Set to past date\r\n      maxAge: 0,\r\n    });\r\n  }\r\n\r\n  // Check if a cookie exists\r\n  has(name: string): boolean {\r\n    return this.get(name) !== null;\r\n  }\r\n\r\n  // Get all cookies as an object\r\n  getAll(): Record<string, string> {\r\n    if (typeof document === \"undefined\") {\r\n      return {};\r\n    }\r\n\r\n    try {\r\n      const cookies: Record<string, string> = {};\r\n      const cookieStrings = document.cookie.split(\";\");\r\n\r\n      for (let cookie of cookieStrings) {\r\n        cookie = cookie.trim();\r\n        const [encodedName, ...valueParts] = cookie.split(\"=\");\r\n\r\n        if (encodedName && valueParts.length > 0) {\r\n          const name = decodeURIComponent(encodedName);\r\n          const value = decodeURIComponent(valueParts.join(\"=\"));\r\n\r\n          // Remove prefix if it exists\r\n          const finalName = this.config.prefix && name.startsWith(this.config.prefix) ? name.substring(this.config.prefix.length) : name;\r\n\r\n          cookies[finalName] = value;\r\n        }\r\n      }\r\n\r\n      return cookies;\r\n    } catch (error) {\r\n      console.error(\"CookieManager: Error getting all cookies\", error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  // Clear all cookies (only those with the same prefix if configured)\r\n  clear(options: Pick<CookieOptions, \"path\" | \"domain\"> = {}): void {\r\n    const allCookies = this.getAll();\r\n\r\n    Object.keys(allCookies).forEach((name) => {\r\n      this.remove(name, options);\r\n    });\r\n  }\r\n\r\n  // Get cookie size in bytes\r\n  getSize(name: string): number {\r\n    const value = this.get(name);\r\n    if (value === null) return 0;\r\n\r\n    return new Blob([value]).size;\r\n  }\r\n\r\n  // Get total cookies size\r\n  getTotalSize(): number {\r\n    if (typeof document === \"undefined\") return 0;\r\n\r\n    return new Blob([document.cookie]).size;\r\n  }\r\n\r\n  // Check if cookies are enabled\r\n  isEnabled(): boolean {\r\n    if (typeof document === \"undefined\") return false;\r\n\r\n    try {\r\n      const testCookie = \"__cookie_test__\";\r\n      this.set(testCookie, \"test\");\r\n      const isEnabled = this.has(testCookie);\r\n      this.remove(testCookie);\r\n      return isEnabled;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n// Default cookie manager instance\r\nexport const cookieManager = new CookieManager();\r\n\r\n// Utility functions for quick access\r\nexport const setCookie = (name: string, value: string, options?: CookieOptions): boolean => {\r\n  return cookieManager.set(name, value, options);\r\n};\r\n\r\nexport const getCookie = (name: string): string | null => {\r\n  return cookieManager.get(name);\r\n};\r\n\r\nexport const getCookieJSON = <T = any>(name: string): T | null => {\r\n  return cookieManager.getJSON<T>(name);\r\n};\r\n\r\nexport const setCookieJSON = (name: string, value: any, options?: CookieOptions): boolean => {\r\n  return cookieManager.setJSON(name, value, options);\r\n};\r\n\r\nexport const removeCookie = (name: string, options?: Pick<CookieOptions, \"path\" | \"domain\">): boolean => {\r\n  return cookieManager.remove(name, options);\r\n};\r\n\r\nexport const hasCookie = (name: string): boolean => {\r\n  return cookieManager.has(name);\r\n};\r\n\r\nexport const getAllCookies = (): Record<string, string> => {\r\n  return cookieManager.getAll();\r\n};\r\n\r\nexport const clearAllCookies = (options?: Pick<CookieOptions, \"path\" | \"domain\">): void => {\r\n  return cookieManager.clear(options);\r\n};\r\n\r\nexport const isCookiesEnabled = (): boolean => {\r\n  return cookieManager.isEnabled();\r\n};\r\n\r\n// Create a custom cookie manager with specific configuration\r\nexport const createCookieManager = (config: CookieManagerConfig): CookieManager => {\r\n  return new CookieManager(config);\r\n};\r\n","import { AuthToken } from \"../types\";\r\nimport { getCookieJSON, removeCookie } from \"./cookieManager\";\r\n\r\nexport const getAuthToken = (): AuthToken | null => {\r\n  const token = getCookieJSON(\"token\");\r\n  if (token?.access_token) {\r\n    return token;\r\n  }\r\n  return null;\r\n};\r\n\r\nexport const logoutAuthUser = (callback?: () => void): void => {\r\n  removeCookie(\"token\");\r\n  removeCookie(\"auth\");\r\n  callback?.();\r\n};\r\n","export interface ApiClientConfig {\r\n  baseURL: string;\r\n  timeout?: number;\r\n  headers?: Record<string, string>;\r\n  withCredentials?: boolean;\r\n}\r\n\r\nexport interface ApiResponse<T = any> {\r\n  data?: T;\r\n  status_code: number;\r\n  success?: boolean;\r\n  code: string;\r\n  message?: string;\r\n  headers: Record<string, string>;\r\n}\r\n\r\nexport interface ApiError {\r\n  data?: any;\r\n  status_code: number;\r\n  success?: boolean;\r\n  code: string;\r\n  message?: string;\r\n}\r\n\r\nexport type RequestMethod = \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\r\n\r\nexport interface RequestConfig {\r\n  method?: RequestMethod;\r\n  headers?: Record<string, string>;\r\n  body?: any;\r\n  params?: Record<string, string | number | boolean>;\r\n  timeout?: number;\r\n  withCredentials?: boolean;\r\n}\r\n\r\ntype InterceptorType = {\r\n  request: Array<(config: RequestConfig) => RequestConfig | Promise<RequestConfig>>;\r\n  response: Array<(response: ApiResponse) => ApiResponse | Promise<ApiResponse>>;\r\n  error: Array<(error: ApiError) => ApiError | Promise<ApiError>>;\r\n};\r\n\r\nconst GlobalInterceptors: InterceptorType = {\r\n  request: [],\r\n  response: [],\r\n  error: [],\r\n};\r\n\r\nexport class ApiClient {\r\n  private static instances: Map<string, ApiClient> = new Map();\r\n\r\n  private config: ApiClientConfig;\r\n  private localInterceptors: InterceptorType;\r\n\r\n  private constructor(config: ApiClientConfig) {\r\n    this.config = config;\r\n    this.localInterceptors = {\r\n      request: [],\r\n      response: [],\r\n      error: [],\r\n    };\r\n  }\r\n\r\n  // Singleton per unique key (e.g., baseURL or custom ID)\r\n  static getInstance(config: ApiClientConfig): ApiClient | undefined {\r\n    const key = config.baseURL;\r\n    if (!key) return undefined;\r\n\r\n    if (!ApiClient.instances.has(key)) {\r\n      ApiClient.instances.set(key, new ApiClient(config));\r\n    }\r\n    return ApiClient.instances.get(key)!;\r\n  }\r\n\r\n  static addGlobalRequestInterceptor(interceptor: (config: RequestConfig) => RequestConfig | Promise<RequestConfig>) {\r\n    GlobalInterceptors.request.push(interceptor);\r\n  }\r\n\r\n  static addGlobalResponseInterceptor(interceptor: (response: ApiResponse) => ApiResponse | Promise<ApiResponse>) {\r\n    GlobalInterceptors.response.push(interceptor);\r\n  }\r\n\r\n  static addGlobalErrorInterceptor(interceptor: (error: ApiError) => ApiError | Promise<ApiError>) {\r\n    GlobalInterceptors.error.push(interceptor);\r\n  }\r\n\r\n  // Local (instance-level) interceptors\r\n  addRequestInterceptor(interceptor: (config: RequestConfig) => RequestConfig | Promise<RequestConfig>) {\r\n    this.localInterceptors.request.push(interceptor);\r\n  }\r\n\r\n  addResponseInterceptor(interceptor: (response: ApiResponse) => ApiResponse | Promise<ApiResponse>) {\r\n    this.localInterceptors.response.push(interceptor);\r\n  }\r\n\r\n  addErrorInterceptor(interceptor: (error: ApiError) => ApiError | Promise<ApiError>) {\r\n    this.localInterceptors.error.push(interceptor);\r\n  }\r\n\r\n  private async applyInterceptors<T>(type: keyof InterceptorType, input: T): Promise<T> {\r\n    const all = [...GlobalInterceptors[type], ...this.localInterceptors[type]];\r\n    let result = input;\r\n\r\n    for (const fn of all) {\r\n      result = (await fn(result as any)) as unknown as T;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // Build URL with query parameters\r\n  private buildURL(endpoint: string, params?: Record<string, string | number | boolean>): string {\r\n    const url = new URL(endpoint, this.config.baseURL);\r\n\r\n    if (params) {\r\n      Object.entries(params).forEach(([key, value]) => {\r\n        url.searchParams.append(key, String(value));\r\n      });\r\n    }\r\n\r\n    return url.toString();\r\n  }\r\n\r\n  // Main request method\r\n  async request<T = any>(endpoint: string, config: RequestConfig = {}): Promise<ApiResponse<T>> {\r\n    try {\r\n      // Apply request interceptors\r\n      const modifiedConfig = await this.applyInterceptors(\"request\", config);\r\n\r\n      // Build URL\r\n      const url = this.buildURL(endpoint, modifiedConfig.params);\r\n\r\n      // Prepare headers\r\n      const headers = {\r\n        \"Content-Type\": \"application/json\",\r\n        Accept: \"application/json\",\r\n        ...this.config.headers,\r\n        ...modifiedConfig.headers,\r\n      };\r\n\r\n      // Prepare fetch options\r\n      const fetchOptions: RequestInit = {\r\n        method: modifiedConfig.method || \"GET\",\r\n        headers,\r\n        credentials: modifiedConfig.withCredentials ?? this.config.withCredentials ? \"include\" : \"same-origin\",\r\n      };\r\n\r\n      // Add body for non-GET requests\r\n      if (modifiedConfig.body && modifiedConfig.method !== \"GET\") {\r\n        fetchOptions.body = typeof modifiedConfig.body === \"string\" ? modifiedConfig.body : JSON.stringify(modifiedConfig.body);\r\n      }\r\n\r\n      // Set up timeout\r\n      const timeout = modifiedConfig.timeout || this.config.timeout || 10000;\r\n      const controller = new AbortController();\r\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\r\n\r\n      fetchOptions.signal = controller.signal;\r\n\r\n      // Make the request\r\n      const response = await fetch(url, fetchOptions);\r\n      clearTimeout(timeoutId);\r\n\r\n      // Parse response\r\n      let data: T;\r\n      const contentType = response.headers.get(\"content-type\");\r\n\r\n      if (contentType && contentType.includes(\"application/json\")) {\r\n        data = await response.json();\r\n      } else {\r\n        data = (await response.text()) as unknown as T;\r\n      }\r\n\r\n      // Create response object\r\n      // const apiResponse: ApiResponse<T> = {\r\n      //   data,\r\n      //   status: response.status,\r\n      //   statusText: response.statusText,\r\n      //   headers: Object.fromEntries(response.headers.entries()),\r\n      // };\r\n      const apiResponse: ApiResponse<T> = data as ApiResponse<T>;\r\n\r\n      // Check if response is successful\r\n      if (!response.ok || response.status < 200 || response.status >= 300) {\r\n        // const error: ApiError = {\r\n        //   message: `Request failed with status ${response.status}`,\r\n        //   status: response.status,\r\n        //   statusText: response.statusText,\r\n        //   data,\r\n        // };\r\n        const error: ApiError = data as ApiError;\r\n\r\n        throw await this.applyInterceptors(\"error\", error);\r\n      }\r\n\r\n      // Apply response interceptors\r\n      return await this.applyInterceptors(\"response\", apiResponse);\r\n    } catch (error) {\r\n      if (error instanceof Error) {\r\n        const apiError: ApiError = {\r\n          message: error.message,\r\n          code: \"REQUEST_ERROR\",\r\n          status_code: 500,\r\n        };\r\n\r\n        throw await this.applyInterceptors(\"error\", apiError);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Convenience methods\r\n  async get<T = any>(endpoint: string, config?: Omit<RequestConfig, \"method\">): Promise<ApiResponse<T>> {\r\n    return this.request<T>(endpoint, { ...config, method: \"GET\" });\r\n  }\r\n\r\n  async post<T = any>(endpoint: string, data?: any, config?: Omit<RequestConfig, \"method\" | \"body\">): Promise<ApiResponse<T>> {\r\n    return this.request<T>(endpoint, { ...config, method: \"POST\", body: data });\r\n  }\r\n\r\n  async put<T = any>(endpoint: string, data?: any, config?: Omit<RequestConfig, \"method\" | \"body\">): Promise<ApiResponse<T>> {\r\n    return this.request<T>(endpoint, { ...config, method: \"PUT\", body: data });\r\n  }\r\n\r\n  async patch<T = any>(endpoint: string, data?: any, config?: Omit<RequestConfig, \"method\" | \"body\">): Promise<ApiResponse<T>> {\r\n    return this.request<T>(endpoint, { ...config, method: \"PATCH\", body: data });\r\n  }\r\n\r\n  async delete<T = any>(endpoint: string, config?: Omit<RequestConfig, \"method\">): Promise<ApiResponse<T>> {\r\n    return this.request<T>(endpoint, { ...config, method: \"DELETE\" });\r\n  }\r\n}\r\n\r\n// Create a default API client instance\r\nexport const createApiClient = (config: ApiClientConfig): ApiClient => {\r\n  return ApiClient.getInstance(config);\r\n};\r\n\r\n// Utility function for quick API calls without creating a client\r\nexport const apiCall = async <T = any>(url: string, config: RequestConfig & { baseURL?: string } = {}): Promise<ApiResponse<T>> => {\r\n  const { baseURL = \"\", ...requestConfig } = config;\r\n  const client = ApiClient.getInstance({ baseURL });\r\n  return client.request<T>(url, requestConfig);\r\n};\r\n","import { toast } from \"sonner\";\r\nimport { envConstants } from \"../constants\";\r\nimport { ApiClient } from \"./apiClient\";\r\n\r\ntype BaseUrlType = keyof typeof envConstants.BASE_API_URL;\r\n\r\nconst baseUrls: Record<BaseUrlType, string> = envConstants.BASE_API_URL;\r\n\r\n// REQUEST INTERCEPTOR Already applied in AuthProvider\r\n\r\n// RESPONSE INTERCEPTOR\r\nApiClient.addGlobalErrorInterceptor(async (error) => {\r\n  console.log(\"❌ API ERROR:\", error);\r\n  if (error?.message) {\r\n    toast.error(error.message);\r\n  }\r\n  return error;\r\n});\r\n\r\nApiClient.addGlobalResponseInterceptor(async (response) => {\r\n  console.log(\"✅ Response received:\", response);\r\n  if (response?.message) {\r\n    toast.success(response.message);\r\n  }\r\n  return response;\r\n});\r\n\r\nconst createApiMethods = (client: ApiClient) => ({\r\n  client,\r\n  get: client.get,\r\n  post: client.post,\r\n  put: client.put,\r\n  patch: client.patch,\r\n  del: client.delete,\r\n});\r\n\r\nconst createClient = (baseURL: string): ApiClient => {\r\n  return ApiClient.getInstance({ baseURL });\r\n};\r\n\r\nconst extendedClient = {\r\n  addGlobalRequestInterceptor: ApiClient.addGlobalRequestInterceptor,\r\n  addGlobalResponseInterceptor: ApiClient.addGlobalResponseInterceptor,\r\n  addGlobalErrorInterceptor: ApiClient.addGlobalErrorInterceptor,\r\n  getInstance: ApiClient.getInstance,\r\n};\r\n\r\ntype ApiServiceMap = Record<BaseUrlType, ReturnType<typeof createApiMethods>>;\r\n\r\n// @ts-ignore\r\nconst ApiInstance: ApiServiceMap & {\r\n  client: typeof extendedClient;\r\n} = {\r\n  client: extendedClient,\r\n  ...Object.fromEntries(Object.entries(baseUrls).map(([name, url]) => [name, createClient(url)])),\r\n};\r\n\r\nexport { ApiInstance };\r\n","import {\r\n  S3Client,\r\n  CreateMultipartUploadCommand,\r\n  UploadPartCommand,\r\n  CompleteMultipartUploadCommand,\r\n  AbortMultipartUploadCommand,\r\n  PutBucketCorsCommandInput,\r\n  DeleteObjectCommand,\r\n  PutBucketCorsCommand,\r\n  PutObjectCommand, // Added for deleteFile\r\n} from \"@aws-sdk/client-s3\";\r\nimport { createHash } from \"crypto\";\r\n\r\n// Environment variables\r\nconst ACCOUNT_ID = process.env.NEXT_PUBLIC_R2_ACCOUNT_ID;\r\nconst S3_BUCKET = process.env.NEXT_PUBLIC_AWS_S3_PUBLIC_BUCKET;\r\nconst ACCESS_KEY = process.env.NEXT_PUBLIC_AWS_ACCESS_KEY_ID;\r\nconst SECRET_KEY = process.env.NEXT_PUBLIC_AWS_SECRET_ACCESS_KEY;\r\n\r\n// Validate environment variables\r\nif (!ACCOUNT_ID || !S3_BUCKET || !ACCESS_KEY || !SECRET_KEY) {\r\n  throw new Error(\r\n    \"Missing required environment variables for R2 configuration\"\r\n  );\r\n}\r\nconst input = {\r\n  // PutBucketCorsRequest\r\n  Bucket: S3_BUCKET, // required\r\n  CORSConfiguration: {\r\n    CORSRules: [\r\n      {\r\n        AllowedHeaders: [\"*\"],\r\n        AllowedMethods: [\"PUT\", \"POST\", \"HEAD\", \"GET\"],\r\n        AllowedOrigins: [\"http://localhost:3000\"],\r\n        ExposeHeaders: [],\r\n        MaxAgeSeconds: 3000,\r\n      },\r\n    ],\r\n  },\r\n};\r\n// Hash the secret access key\r\nconst hashedSecretKey =  createHash(\"sha256\").update(SECRET_KEY).digest(\"hex\");\r\n\r\n// Configure S3 client for Cloudflare R2\r\nconst s3Client = new S3Client({\r\n  endpoint: `https://${ACCOUNT_ID}.r2.cloudflarestorage.com`,\r\n  region: \"auto\", // Cloudflare R2 doesn't use regions, but required by SDK\r\n  credentials: {\r\n    accessKeyId: ACCESS_KEY,\r\n    secretAccessKey: SECRET_KEY// hashedSecretKey,\r\n  },\r\n  signatureVersion: \"v4\",\r\n});\r\nconsole.log(\r\n  \"s3Client  Data\",\r\n  s3Client.config.endpoint,\r\n  s3Client.config.credentials\r\n);\r\n\r\nconst CHUNK_SIZE = 5 * 1024 * 1024; // 5MB per chunk\r\n\r\n// Function to create file chunks\r\nconst createChunks = (file: File): Blob[] => {\r\n  if (!(file instanceof File)) {\r\n    throw new Error(\"Invalid file object provided\");\r\n  }\r\n  console.log(\"File size:\", file.size, \"Chunk size:\", CHUNK_SIZE);\r\n  const chunks: Blob[] = [];\r\n  let currentByte = 0;\r\n\r\n  while (currentByte < file.size) {\r\n    const chunk = file.slice(currentByte, currentByte + CHUNK_SIZE);\r\n    chunks.push(chunk);\r\n    currentByte += CHUNK_SIZE;\r\n  }\r\n  console.log(\"Total chunks created:\", chunks.length);\r\n  return chunks;\r\n};\r\n\r\nexport const uploadFileInChunks = async (\r\n  file: File,\r\n  fileName: string,\r\n  fileType: string,\r\n  uniqueFileKey: string,\r\n  setProgress: (progress: Record<string, number>) => void,\r\n  folderName: string = new Date(Date.now()).toLocaleDateString(\"en-GB\")\r\n): Promise<string> => {\r\n  const chunks = createChunks(file);\r\n  console.log(\"Starting upload to bucket:\", S3_BUCKET);\r\n  const uploadId = await initiateMultipartUpload(\r\n    fileName,\r\n    fileType,\r\n    folderName,\r\n  file\r\n  );\r\n  const uploadPromises = chunks.map((chunk, index) =>\r\n    uploadChunk(uploadId, chunk, index + 1, fileName, folderName).then(\r\n      (part) => {\r\n        const progress = Math.round(((index + 1) / chunks.length) * 100);\r\n        setProgress({ [uniqueFileKey]: progress });\r\n        return part;\r\n      }\r\n    )\r\n  );\r\n\r\n  try {\r\n    const parts = await Promise.all(uploadPromises);\r\n    const result = await completeMultipartUpload(\r\n      uploadId,\r\n      parts,\r\n      fileName,\r\n      folderName\r\n    );\r\n    setProgress({ [uniqueFileKey]: 100 });\r\n    return result;\r\n  } catch (error) {\r\n    console.error(\"Upload failed:\", error);\r\n    await abortMultipartUpload(uploadId, fileName, folderName);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Initiate multipart upload\r\nconst initiateMultipartUpload = async (\r\n  fileName: string,\r\n  fileType: string,\r\n  folderName: string,\r\n  file: any\r\n): Promise<string> => {\r\n  const chunkArrayBuffer = await file.arrayBuffer();\r\n  const chunkUint8Array = new Uint8Array(chunkArrayBuffer);\r\n  // const commandNew = new PutObjectCommand({\r\n  //   Bucket: S3_BUCKET,\r\n  //   Key: `${folderName}${fileName}`,\r\n  //   Body: chunkUint8Array,\r\n  //   // CORSConfiguration: {\r\n  //   //   CORSRules: [\r\n  //   //     {\r\n  //   //       AllowedHeaders: [\"content-type\"],\r\n  //   //       AllowedMethods: [\"PUT\", \"POST\", \"HEAD\", \"GET\"],\r\n  //   //       AllowedOrigins: [\"*\"],\r\n  //   //       ExposeHeaders: [],\r\n  //   //       MaxAgeSeconds: 3000,\r\n  //   //     },\r\n  //   //   ],\r\n  //   // },\r\n  // });\r\n  const command = new CreateMultipartUploadCommand({\r\n    Bucket: S3_BUCKET,\r\n    Key: `${folderName}${fileName}`,\r\n    ContentType: fileType,\r\n    ACL:\"public-read\",\r\n    ...input.CORSConfiguration,\r\n  });\r\n  console.log(\"command\", command);\r\n  try {\r\n    const response = await s3Client.send(command);\r\n    if (!response.UploadId) {\r\n      throw new Error('UploadId not returned from R2');\r\n    }\r\n    console.log(\"Upload initiated with ID:\", response);\r\n    return response.UploadId;\r\n  } catch (error) {\r\n    console.error(\"Failed to initiate multipart upload:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Upload a single chunk\r\nconst uploadChunk = async (\r\n  uploadId: string,\r\n  chunk: Blob,\r\n  partNumber: number,\r\n  fileName: string,\r\n  folderName: string\r\n): Promise<{ ETag: string; PartNumber: number }> => {\r\n  const chunkArrayBuffer = await chunk.arrayBuffer();\r\n  const chunkUint8Array = new Uint8Array(chunkArrayBuffer);\r\n\r\n  const command = new UploadPartCommand({\r\n    Bucket: S3_BUCKET,\r\n    Key: `${folderName}${fileName}`,\r\n    PartNumber: partNumber,\r\n    UploadId: uploadId,\r\n    Body: chunkUint8Array,\r\n    ...input.CORSConfiguration,\r\n  });\r\n\r\n  try {\r\n    const response = await s3Client.send(command);\r\n    if (!response.ETag) {\r\n      throw new Error(`No ETag returned for part ${partNumber}`);\r\n    }\r\n    console.log(`Uploaded part ${partNumber}:`, response.ETag);\r\n    return {\r\n      ETag: response.ETag,\r\n      PartNumber: partNumber,\r\n    };\r\n  } catch (error) {\r\n    console.error(`Failed to upload part ${partNumber}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Complete multipart upload\r\nconst completeMultipartUpload = async (\r\n  uploadId: string,\r\n  parts: { ETag: string; PartNumber: number }[],\r\n  fileName: string,\r\n  folderName: string\r\n): Promise<string> => {\r\n  const sortedParts = parts.sort((a, b) => a.PartNumber - b.PartNumber);\r\n  const command = new CompleteMultipartUploadCommand({\r\n    Bucket: S3_BUCKET,\r\n    Key: `${folderName}${fileName}`,\r\n    UploadId: uploadId,\r\n    MultipartUpload: { Parts: sortedParts },\r\n    ...input.CORSConfiguration,\r\n  });\r\n\r\n  try {\r\n    const response = await s3Client.send(command);\r\n    if (!response.Key) {\r\n      throw new Error(\"No Key returned after completing upload\");\r\n    }\r\n    console.log(\"Upload completed successfully. Key:\", response.Key);\r\n    return response.Key;\r\n  } catch (error) {\r\n    console.error(\"Failed to complete multipart upload:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Abort multipart upload\r\nconst abortMultipartUpload = async (\r\n  uploadId: string,\r\n  fileName: string,\r\n  folderName: string\r\n): Promise<void> => {\r\n  const command = new AbortMultipartUploadCommand({\r\n    Bucket: S3_BUCKET,\r\n    Key: `${folderName}${fileName}`,\r\n    UploadId: uploadId,\r\n    ...input.CORSConfiguration,\r\n  });\r\n\r\n  try {\r\n    await s3Client.send(command);\r\n    console.log(\"Multipart upload aborted successfully:\", uploadId);\r\n  } catch (error) {\r\n    console.error(\"Failed to abort multipart upload:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Delete file\r\nexport const deleteFile = async (\r\n  filepath: string,\r\n  onProgress?: (progress: any) => void\r\n): Promise<{ ETag?: string }> => {\r\n  const command = new DeleteObjectCommand({\r\n    Bucket: S3_BUCKET,\r\n    Key: filepath,\r\n    ...input.CORSConfiguration,\r\n  });\r\n\r\n  try {\r\n    const response = await s3Client.send(command);\r\n    console.log(\"File deleted successfully:\", filepath);\r\n    // Optionally call onProgress if provided\r\n    if (onProgress) {\r\n      onProgress({ loaded: 1, total: 1 });\r\n    }\r\n    return { ETag: response.DeleteMarker?.toString() };\r\n  } catch (error) {\r\n    console.error(\"Failed to delete file:\", error);\r\n    throw error;\r\n  }\r\n};\r\n","export const apiEndpoints = {\r\n  auth: {\r\n    profile: \"profile\",\r\n    logout: \"auth/logout/\",\r\n  },\r\n};\r\n","\"use client\";\r\nimport React, { createContext, useContext, useReducer, useEffect, useCallback, ReactNode } from \"react\";\r\nimport { cookieManager, setCookie, setCookieJSON } from \"../utils/cookieManager\";\r\nimport { User, AuthToken, AuthState, AuthContextValue, AuthProviderConfig, AuthAction } from \"../types/auth.type\";\r\nimport { getAuthToken, logoutAuthUser } from \"../utils/auth.utils\";\r\nimport { ApiInstance } from \"../utils\";\r\nimport { envConstants } from \"../constants\";\r\nimport { apiEndpoints } from \"../constants/api-endpoints.constants\";\r\nimport getSubDomain from \"../utils/getSubDomain\";\r\n\r\n// Default configuration\r\nconst defaultConfig: Required<AuthProviderConfig> = {\r\n  tokenStorage: {\r\n    cookieOptions: {\r\n      secure: true,\r\n      sameSite: \"lax\",\r\n      path: \"/\",\r\n    },\r\n  },\r\n  redirectOnUnauthorized: envConstants.APP_URL.ACCOUNT + `/login`,\r\n  isAccountDomain: false,\r\n  onAuthStateChange: () => {},\r\n};\r\n\r\n// Initial state\r\nconst initialState: AuthState = {\r\n  user: null,\r\n  token: {\r\n    access_token: null,\r\n    expires_at: null,\r\n    token_type: null,\r\n  },\r\n  isAuthenticated: false,\r\n  isLoading: true,\r\n  error: null,\r\n};\r\n\r\n// Auth reducer\r\nconst authReducer = (state: AuthState, action: AuthAction): AuthState => {\r\n  switch (action.type) {\r\n    case \"SET_LOADING\":\r\n      return { ...state, isLoading: action.payload };\r\n\r\n    case \"SET_ERROR\":\r\n      return { ...state, error: action.payload, isLoading: false };\r\n\r\n    case \"SET_USER\":\r\n      return {\r\n        ...state,\r\n        user: action.payload,\r\n        isAuthenticated: !!action.payload,\r\n        error: null,\r\n      };\r\n\r\n    case \"SET_TOKENS\":\r\n      return { ...state, token: action.payload };\r\n\r\n    case \"SET_AUTHENTICATED\":\r\n      return { ...state, isAuthenticated: action.payload };\r\n\r\n    case \"UPDATE_USER\":\r\n      return {\r\n        ...state,\r\n        user: state.user ? { ...state.user, ...action.payload } : null,\r\n      };\r\n\r\n    case \"CLEAR_AUTH\":\r\n      return {\r\n        ...initialState,\r\n        isLoading: false,\r\n      };\r\n\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\n// Create context\r\nconst AuthContext = createContext<AuthContextValue | undefined>(undefined);\r\n\r\n// Auth Provider component\r\nexport interface AuthProviderProps {\r\n  children: ReactNode;\r\n  config?: AuthProviderConfig;\r\n}\r\n\r\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children, config }) => {\r\n  const [state, dispatch] = useReducer(authReducer, initialState);\r\n  const mergedConfig = { ...defaultConfig, ...(config ?? {}) };\r\n\r\n  // Token management\r\n  const updateToken = useCallback((token: AuthToken) => {\r\n    setCookieJSON(\"token\", token);\r\n    setCookie(\"auth\", token?.access_token);\r\n    dispatch({ type: \"SET_TOKENS\", payload: token });\r\n  }, []);\r\n\r\n  const logoutUser = useCallback((callback?: () => void) => {\r\n    logoutAuthUser(() => {\r\n      dispatch({ type: \"CLEAR_AUTH\" });\r\n      callback?.();\r\n    });\r\n  }, []);\r\n\r\n  const getToken = useCallback(() => {\r\n    const token = getAuthToken();\r\n    if (!token?.access_token) {\r\n      const domain = getSubDomain();\r\n      if (!mergedConfig?.isAccountDomain) {\r\n        window.location.assign(mergedConfig.redirectOnUnauthorized + `?redirect_url=${window.location.href}`);\r\n      } else {\r\n        window.location.pathname = \"/login\";\r\n      }\r\n    }\r\n    return token;\r\n  }, []);\r\n\r\n  // API request interceptor to add auth token\r\n  useEffect(() => {\r\n    ApiInstance.client.addGlobalRequestInterceptor(async (config) => {\r\n      const token = getToken();\r\n      if (token?.access_token) {\r\n        config.headers = {\r\n          ...config.headers,\r\n          Authorization: `Bearer ${token?.access_token}`,\r\n        };\r\n      }\r\n      return config;\r\n    });\r\n\r\n    // Response interceptor to handle token refresh\r\n    ApiInstance.client.addGlobalErrorInterceptor(async (error) => {\r\n      if (error.status_code === 401) {\r\n        try {\r\n          logoutUser(() => {\r\n            // Redirect to login page or handle unauthorized access\r\n          });\r\n        } catch (refreshError) {\r\n          console.error(\"Token refresh failed:\", refreshError);\r\n          dispatch({ type: \"SET_ERROR\", payload: \"Session expired. Please log in again.\" });\r\n        }\r\n      }\r\n      return error;\r\n    });\r\n\r\n    refreshUser();\r\n  }, []);\r\n\r\n  // Authentication methods\r\n  const refreshUser = useCallback(async () => {\r\n    dispatch({ type: \"SET_LOADING\", payload: true });\r\n    dispatch({ type: \"SET_ERROR\", payload: null });\r\n    ApiInstance.CORE.get<{ seller: User }>(apiEndpoints.auth.profile)\r\n      .then((res) => {\r\n        const user = res?.data?.seller;\r\n        setUser(user);\r\n      })\r\n      .catch((err) => {\r\n        dispatch({ type: \"SET_ERROR\", payload: err.message || \"Login failed\" });\r\n      })\r\n      .finally(() => {\r\n        dispatch({ type: \"SET_LOADING\", payload: false });\r\n      });\r\n  }, []);\r\n\r\n  // Set User\r\n  const setUser = useCallback((user: User) => {\r\n    dispatch({ type: \"SET_USER\", payload: user });\r\n  }, []);\r\n\r\n  // Utility methods\r\n  const clearError = useCallback(() => {\r\n    dispatch({ type: \"SET_ERROR\", payload: null });\r\n  }, []);\r\n\r\n  // Notify auth state changes\r\n  useEffect(() => {\r\n    mergedConfig.onAuthStateChange(state);\r\n  }, [state, mergedConfig.onAuthStateChange]);\r\n\r\n  const contextValue: AuthContextValue = {\r\n    ...state,\r\n    setUser,\r\n    getToken,\r\n    updateToken,\r\n    logout: logoutUser,\r\n    refreshUser,\r\n    config: mergedConfig,\r\n  };\r\n\r\n  return <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>;\r\n};\r\n\r\n// Hook to use auth context\r\nexport const useAuth = (): AuthContextValue => {\r\n  const context = useContext(AuthContext);\r\n  // if (context === undefined) {\r\n  //   throw new Error(\"useAuth must be used within an AuthProvider\");\r\n  // }\r\n  return context;\r\n};\r\n\r\nexport { AuthContext };\r\n","const getSubDomain = () => {\r\n  if (typeof window !== \"undefined\") {\r\n    const hostname = window?.location?.hostname;\r\n    return hostname?.split(\".\")?.[0];\r\n    if (process.env.NODE_ENV === \"production\" ? hostname?.includes(\"crezlo.site\") : hostname?.includes(\"localhost\")) {\r\n      const domain = hostname?.split(\".\")?.[0];\r\n      return `${domain}.${process.env.NEXT_PUBLIC_WEBSITE_PREVIEW_DOMAIN_API}`;\r\n    }\r\n    return hostname;\r\n  }\r\n  return null;\r\n};\r\nexport default getSubDomain;\r\n","\"use client\";\r\nimport { createContext, Dispatch, SetStateAction, useContext, useState } from \"react\";\r\n\r\ninterface ContextProps {\r\n  sidebarOpen: boolean;\r\n  setSidebarOpen: (value: boolean) => void;\r\n  sidebarExpanded: boolean;\r\n  setSidebarExpanded: (value: boolean) => void;\r\n}\r\n\r\nconst AppContext = createContext<ContextProps>({\r\n  sidebarOpen: true,\r\n  setSidebarOpen: (value: boolean) => {},\r\n  sidebarExpanded: true,\r\n  setSidebarExpanded: (value: boolean) => {},\r\n});\r\n\r\nexport function AppProvider({ children }: { children: React.ReactNode }) {\r\n  const [sidebarOpen, setSidebarOpen] = useState<boolean>(true);\r\n  const [sidebarExpanded, setSidebarExpanded] = useState<boolean>(true);\r\n  return (\r\n    <AppContext.Provider\r\n      value={{\r\n        sidebarOpen,\r\n        setSidebarOpen,\r\n        sidebarExpanded,\r\n        setSidebarExpanded,\r\n      }}\r\n    >\r\n      {children}\r\n    </AppContext.Provider>\r\n  );\r\n}\r\n\r\nexport const useAppProvider = () => useContext(AppContext);\r\n"],"names":["APP_HTTP","process","env","NODE_ENV","APP_DOMAIN","NEXT_PUBLIC_APP_DOMAIN","ACCOUNT","NEXT_PUBLIC_APP_URL_ACCOUNT","NEXT_PUBLIC_APP_URL_FINANCE","NEXT_PUBLIC_APP_URL_VR","NEXT_PUBLIC_APP_URL_COMMUNITY","NEXT_PUBLIC_APP_URL_WEBSITE","NEXT_PUBLIC_APP_URL_GENAGENT","envConstants","APP_URL","SUBSCRIPTION_TYPE","NEXT_PUBLIC_SUBSCRIPTION_TYPE","BASE_API_URL","CORE","NEXT_PUBLIC_API_URL_CORE","CONTENT","NEXT_PUBLIC_API_URL_CONTENT","CHAT","NEXT_PUBLIC_API_URL_CHAT","GENAGENT","NEXT_PUBLIC_API_GENAGENT_URL","WEBSITE_BUILDER","NEXT_PUBLIC_WEBSITE_BUILDER_URL","CHANNEL_BUILDER","NEXT_PUBLIC_CHANNEL_BUILDERL_URL","FINANCE","NEXT_PUBLIC_FINANCE_URL","cookieManager","config","constructor","this","defaultPath","defaultSecure","window","location","protocol","defaultDomain","set","name","value","options","expires","document","console","warn","cookieName","prefix","cookieString","encodeURIComponent","date","Date","setTime","getTime","toUTCString","undefined","maxAge","path","domain","secure","httpOnly","sameSite","defaultSameSite","log","cookie","error","get","encodedName","cookies","split","trim","startsWith","decodeURIComponent","substring","length","getJSON","JSON","parse","setJSON","jsonString","stringify","remove","has","getAll","cookieStrings","valueParts","join","clear","allCookies","Object","keys","forEach","getSize","Blob","size","getTotalSize","isEnabled","testCookie","removeCookie","getAuthToken","token","access_token","GlobalInterceptors","request","response","ApiClient","static","Map","localInterceptors","getInstance","key","baseURL","instances","addGlobalRequestInterceptor","interceptor","push","addGlobalResponseInterceptor","addGlobalErrorInterceptor","addRequestInterceptor","addResponseInterceptor","addErrorInterceptor","applyInterceptors","type","input","all","result","fn","buildURL","endpoint","params","url","URL","entries","searchParams","append","String","toString","modifiedConfig","headers","Accept","fetchOptions","method","credentials","withCredentials","body","timeout","controller","AbortController","timeoutId","setTimeout","abort","signal","fetch","data","clearTimeout","contentType","includes","json","text","apiResponse","ok","status","Error","apiError","message","code","status_code","post","put","patch","baseUrls","async","toast","success","ApiInstance","client","fromEntries","map","ACCOUNT_ID","NEXT_PUBLIC_R2_ACCOUNT_ID","S3_BUCKET","NEXT_PUBLIC_AWS_S3_PUBLIC_BUCKET","ACCESS_KEY","NEXT_PUBLIC_AWS_ACCESS_KEY_ID","SECRET_KEY","NEXT_PUBLIC_AWS_SECRET_ACCESS_KEY","createHash","update","digest","s3Client","S3Client","region","accessKeyId","secretAccessKey","signatureVersion","apiEndpoints","profile","defaultConfig","tokenStorage","cookieOptions","redirectOnUnauthorized","isAccountDomain","onAuthStateChange","initialState","user","expires_at","token_type","isAuthenticated","isLoading","authReducer","state","action","payload","AuthContext","createContext","AuthProvider","children","dispatch","useReducer","mergedConfig","updateToken","useCallback","setCookie","logoutUser","callback","logoutAuthUser","getToken","hostname","getSubDomain","pathname","assign","href","useEffect","Authorization","refreshError","refreshUser","then","res","seller","setUser","catch","err","finally","contextValue","logout","_jsx","Provider","useAuth","useContext","AppContext","sidebarOpen","setSidebarOpen","sidebarExpanded","setSidebarExpanded","AppProvider","useState","useAppProvider"],"mappings":"iTAAA,MAAMA,EAAoC,eAAzBC,QAAQC,IAAIC,SAA4B,WAAa,UAChEC,EAAaH,QAAQC,IAAIG,uBACzBC,EAAUL,QAAQC,IAAIK,6BAA+B,WAC3CN,QAAQC,IAAIM,4BACjBP,QAAQC,IAAIO,uBACLR,QAAQC,IAAIQ,8BACdT,QAAQC,IAAIS,4BACXV,QAAQC,IAAIU,6BACtB,MAAMC,EAAe,CAC1BT,WAAqC,eAAzBH,QAAQC,IAAIC,SAA4BC,EAAa,eASjEU,QAAS,CACPR,QAAS,GAAGN,IAAWM,KAAWF,KAOpCW,kBAAmBd,QAAQC,IAAIc,8BAC/BC,aAAc,CACZC,KAAMjB,QAAQC,IAAIiB,yBAClBC,QAASnB,QAAQC,IAAImB,4BACrBC,KAAMrB,QAAQC,IAAIqB,yBAClBC,SAAUvB,QAAQC,IAAIuB,6BACtBC,gBAAiBzB,QAAQC,IAAIyB,gCAC7BC,gBAAiB3B,QAAQC,IAAI2B,iCAC7BC,QAAS7B,QAAQC,IAAI6B,0BCuMlB,MAAMC,EAAgB,UApNnBC,OAER,WAAAC,CAAYD,EAA8B,IACxCE,KAAKF,OAAS,CACZG,YAAa,IACbC,cAAiC,oBAAXC,QAAsD,WAA7BA,OAAOC,SAASC,SAC/DC,cAAe,IAAI5B,EAAaT,gBAC7B6B,EAEP,CAGA,GAAAS,CAAIC,EAAcC,EAAeC,EAAyB,CAAEC,QAAS,MACnE,GAAwB,oBAAbC,SAET,OADAC,QAAQC,KAAK,+DACN,EAGT,IACE,MAAMC,EAAaf,KAAKF,OAAOkB,OAAS,GAAGhB,KAAKF,OAAOkB,SAASR,IAASA,EACzE,IAAIS,EAAe,GAAGC,mBAAmBH,MAAeG,mBAAmBT,KAG3E,GAAIC,EAAQC,QACV,GAA+B,iBAApBD,EAAQC,QAAsB,CAEvC,MAAMQ,EAAO,IAAIC,KACjBD,EAAKE,QAAQF,EAAKG,UAA8B,GAAlBZ,EAAQC,QAAe,GAAK,GAAK,KAC/DM,GAAgB,aAAaE,EAAKI,eACpC,MACEN,GAAgB,aAAaP,EAAQC,QAAQY,qBAK1BC,IAAnBd,EAAQe,SACVR,GAAgB,aAAaP,EAAQe,UAIvC,MAAMC,EAAOhB,EAAQgB,MAAQ1B,KAAKF,OAAOG,YACrCyB,IACFT,GAAgB,UAAUS,KAI5B,MAAMC,EAASjB,EAAQiB,QAAU3B,KAAKF,OAAOQ,cACzCqB,IACFV,GAAgB,YAAYU,MAIfjB,EAAQkB,QAAU5B,KAAKF,OAAOI,iBAE3Ce,GAAgB,YAIdP,EAAQmB,UACVhB,QAAQC,KAAK,6DAIf,MAAMgB,EAAWpB,EAAQoB,UAAY9B,KAAKF,OAAOiC,gBAMjD,OALID,IACFb,GAAgB,cAAca,KAEhCjB,QAAQmB,IAAI,kBAAmBf,GAC/BL,SAASqB,OAAShB,GACX,CACT,CAAE,MAAOiB,GAEP,OADArB,QAAQqB,MAAM,uCAAwCA,IAC/C,CACT,CACF,CAGA,GAAAC,CAAI3B,GACF,GAAwB,oBAAbI,SACT,OAAO,KAGT,IACE,MAAMG,EAAaf,KAAKF,OAAOkB,OAAS,GAAGhB,KAAKF,OAAOkB,SAASR,IAASA,EACnE4B,EAAclB,mBAAmBH,GACjCsB,EAAUzB,SAASqB,OAAOK,MAAM,KAEtC,IAAK,IAAIL,KAAUI,EAEjB,GADAJ,EAASA,EAAOM,OACZN,EAAOO,WAAW,GAAGJ,MACvB,OAAOK,mBAAmBR,EAAOS,UAAUN,EAAYO,OAAS,IAIpE,OAAO,IACT,CAAE,MAAOT,GAEP,OADArB,QAAQqB,MAAM,sCAAuCA,GAC9C,IACT,CACF,CAGA,OAAAU,CAAiBpC,GACf,MAAMC,EAAQT,KAAKmC,IAAI3B,GACvB,GAAc,OAAVC,EAAgB,OAAO,KAE3B,IACE,OAAOoC,KAAKC,MAAMrC,EACpB,CAAE,MAAOyB,GAEP,OADArB,QAAQqB,MAAM,2CAA4CA,GACnD,IACT,CACF,CAGA,OAAAa,CAAQvC,EAAcC,EAAYC,EAAyB,CAAA,GACzD,IACE,MAAMsC,EAAaH,KAAKI,UAAUxC,GAClC,OAAOT,KAAKO,IAAIC,EAAMwC,EAAYtC,EACpC,CAAE,MAAOwB,GAEP,OADArB,QAAQqB,MAAM,gDAAiDA,IACxD,CACT,CACF,CAGA,MAAAgB,CAAO1C,EAAcE,EAAkD,IACrE,OAAOV,KAAKO,IAAIC,EAAM,GAAI,IACrBE,EACHC,QAAS,IAAIS,KAAK,GAClBK,OAAQ,GAEZ,CAGA,GAAA0B,CAAI3C,GACF,OAA0B,OAAnBR,KAAKmC,IAAI3B,EAClB,CAGA,MAAA4C,GACE,GAAwB,oBAAbxC,SACT,MAAO,CAAA,EAGT,IACE,MAAMyB,EAAkC,CAAA,EAClCgB,EAAgBzC,SAASqB,OAAOK,MAAM,KAE5C,IAAK,IAAIL,KAAUoB,EAAe,CAChCpB,EAASA,EAAOM,OAChB,MAAOH,KAAgBkB,GAAcrB,EAAOK,MAAM,KAElD,GAAIF,GAAekB,EAAWX,OAAS,EAAG,CACxC,MAAMnC,EAAOiC,mBAAmBL,GAC1B3B,EAAQgC,mBAAmBa,EAAWC,KAAK,MAKjDlB,EAFkBrC,KAAKF,OAAOkB,QAAUR,EAAKgC,WAAWxC,KAAKF,OAAOkB,QAAUR,EAAKkC,UAAU1C,KAAKF,OAAOkB,OAAO2B,QAAUnC,GAErGC,CACvB,CACF,CAEA,OAAO4B,CACT,CAAE,MAAOH,GAEP,OADArB,QAAQqB,MAAM,2CAA4CA,GACnD,CAAA,CACT,CACF,CAGA,KAAAsB,CAAM9C,EAAkD,IACtD,MAAM+C,EAAazD,KAAKoD,SAExBM,OAAOC,KAAKF,GAAYG,QAASpD,IAC/BR,KAAKkD,OAAO1C,EAAME,IAEtB,CAGA,OAAAmD,CAAQrD,GACN,MAAMC,EAAQT,KAAKmC,IAAI3B,GACvB,OAAc,OAAVC,EAAuB,EAEpB,IAAIqD,KAAK,CAACrD,IAAQsD,IAC3B,CAGA,YAAAC,GACE,MAAwB,oBAAbpD,SAAiC,EAErC,IAAIkD,KAAK,CAAClD,SAASqB,SAAS8B,IACrC,CAGA,SAAAE,GACE,GAAwB,oBAAbrD,SAA0B,OAAO,EAE5C,IACE,MAAMsD,EAAa,kBACnBlE,KAAKO,IAAI2D,EAAY,QACrB,MAAMD,EAAYjE,KAAKmD,IAAIe,GAE3B,OADAlE,KAAKkD,OAAOgB,GACLD,CACT,CAAE,MACA,OAAO,CACT,CACF,GAuBWE,EAAe,CAAC3D,EAAcE,IAClCb,EAAcqD,OAAO1C,EAAME,GC1PvB0D,EAAe,KAC1B,MAAMC,GDgP+B7D,EChPT,QDiPrBX,EAAc+C,QAAWpC,IADL,IAAUA,EC/OrC,OAAI6D,GAAOC,aACFD,EAEF,MCiCHE,EAAsC,CAC1CC,QAAS,GACTC,SAAU,GACVvC,MAAO,UAGIwC,EACHC,iBAA2C,IAAIC,IAE/C9E,OACA+E,kBAER,WAAA9E,CAAoBD,GAClBE,KAAKF,OAASA,EACdE,KAAK6E,kBAAoB,CACvBL,QAAS,GACTC,SAAU,GACVvC,MAAO,GAEX,CAGA,kBAAO4C,CAAYhF,GACjB,MAAMiF,EAAMjF,EAAOkF,QACnB,GAAKD,EAKL,OAHKL,EAAUO,UAAU9B,IAAI4B,IAC3BL,EAAUO,UAAU1E,IAAIwE,EAAK,IAAIL,EAAU5E,IAEtC4E,EAAUO,UAAU9C,IAAI4C,EACjC,CAEA,kCAAOG,CAA4BC,GACjCZ,EAAmBC,QAAQY,KAAKD,EAClC,CAEA,mCAAOE,CAA6BF,GAClCZ,EAAmBE,SAASW,KAAKD,EACnC,CAEA,gCAAOG,CAA0BH,GAC/BZ,EAAmBrC,MAAMkD,KAAKD,EAChC,CAGA,qBAAAI,CAAsBJ,GACpBnF,KAAK6E,kBAAkBL,QAAQY,KAAKD,EACtC,CAEA,sBAAAK,CAAuBL,GACrBnF,KAAK6E,kBAAkBJ,SAASW,KAAKD,EACvC,CAEA,mBAAAM,CAAoBN,GAClBnF,KAAK6E,kBAAkB3C,MAAMkD,KAAKD,EACpC,CAEQ,uBAAMO,CAAqBC,EAA6BC,GAC9D,MAAMC,EAAM,IAAItB,EAAmBoB,MAAU3F,KAAK6E,kBAAkBc,IACpE,IAAIG,EAASF,EAEb,IAAK,MAAMG,KAAMF,EACfC,QAAgBC,EAAGD,GAGrB,OAAOA,CACT,CAGQ,QAAAE,CAASC,EAAkBC,GACjC,MAAMC,EAAM,IAAIC,IAAIH,EAAUjG,KAAKF,OAAOkF,SAQ1C,OANIkB,GACFxC,OAAO2C,QAAQH,GAAQtC,QAAQ,EAAEmB,EAAKtE,MACpC0F,EAAIG,aAAaC,OAAOxB,EAAKyB,OAAO/F,MAIjC0F,EAAIM,UACb,CAGA,aAAMjC,CAAiByB,EAAkBnG,EAAwB,IAC/D,IAEE,MAAM4G,QAAuB1G,KAAK0F,kBAAkB,UAAW5F,GAGzDqG,EAAMnG,KAAKgG,SAASC,EAAUS,EAAeR,QAG7CS,EAAU,CACd,eAAgB,mBAChBC,OAAQ,sBACL5G,KAAKF,OAAO6G,WACZD,EAAeC,SAIdE,EAA4B,CAChCC,OAAQJ,EAAeI,QAAU,MACjCH,UACAI,YAAaL,EAAeM,iBAAmBhH,KAAKF,OAAOkH,gBAAkB,UAAY,eAIvFN,EAAeO,MAAkC,QAA1BP,EAAeI,SACxCD,EAAaI,KAAsC,iBAAxBP,EAAeO,KAAoBP,EAAeO,KAAOpE,KAAKI,UAAUyD,EAAeO,OAIpH,MAAMC,EAAUR,EAAeQ,SAAWlH,KAAKF,OAAOoH,SAAW,IAC3DC,EAAa,IAAIC,gBACjBC,EAAYC,WAAW,IAAMH,EAAWI,QAASL,GAEvDL,EAAaW,OAASL,EAAWK,OAGjC,MAAM/C,QAAiBgD,MAAMtB,EAAKU,GAIlC,IAAIa,EAHJC,aAAaN,GAIb,MAAMO,EAAcnD,EAASkC,QAAQxE,IAAI,gBAGvCuF,EADEE,GAAeA,EAAYC,SAAS,0BACzBpD,EAASqD,aAERrD,EAASsD,OAUzB,MAAMC,EAA8BN,EAGpC,IAAKjD,EAASwD,IAAMxD,EAASyD,OAAS,KAAOzD,EAASyD,QAAU,IAAK,CAOnE,MAAMhG,EAAkBwF,EAExB,YAAY1H,KAAK0F,kBAAkB,QAASxD,EAC9C,CAGA,aAAalC,KAAK0F,kBAAkB,WAAYsC,EAClD,CAAE,MAAO9F,GACP,GAAIA,aAAiBiG,MAAO,CAC1B,MAAMC,EAAqB,CACzBC,QAASnG,EAAMmG,QACfC,KAAM,gBACNC,YAAa,KAGf,YAAYvI,KAAK0F,kBAAkB,QAAS0C,EAC9C,CAEA,MAAMlG,CACR,CACF,CAGA,SAAMC,CAAa8D,EAAkBnG,GACnC,OAAOE,KAAKwE,QAAWyB,EAAU,IAAKnG,EAAQgH,OAAQ,OACxD,CAEA,UAAM0B,CAAcvC,EAAkByB,EAAY5H,GAChD,OAAOE,KAAKwE,QAAWyB,EAAU,IAAKnG,EAAQgH,OAAQ,OAAQG,KAAMS,GACtE,CAEA,SAAMe,CAAaxC,EAAkByB,EAAY5H,GAC/C,OAAOE,KAAKwE,QAAWyB,EAAU,IAAKnG,EAAQgH,OAAQ,MAAOG,KAAMS,GACrE,CAEA,WAAMgB,CAAezC,EAAkByB,EAAY5H,GACjD,OAAOE,KAAKwE,QAAWyB,EAAU,IAAKnG,EAAQgH,OAAQ,QAASG,KAAMS,GACvE,CAEA,YAAM,CAAgBzB,EAAkBnG,GACtC,OAAOE,KAAKwE,QAAWyB,EAAU,IAAKnG,EAAQgH,OAAQ,UACxD,EChOF,MAAM6B,EAAwCjK,EAAaI,aAK3D4F,EAAUY,0BAA0BsD,MAAO1G,IACzCrB,QAAQmB,IAAI,eAAgBE,GACxBA,GAAOmG,SACTQ,EAAM3G,MAAMA,EAAMmG,SAEbnG,IAGTwC,EAAUW,6BAA6BuD,MAAOnE,IAC5C5D,QAAQmB,IAAI,uBAAwByC,GAChCA,GAAU4D,SACZQ,EAAMC,QAAQrE,EAAS4D,SAElB5D,IAYT,MAcMsE,EAEF,CACFC,OAbqB,CACrB9D,4BAA6BR,EAAUQ,4BACvCG,6BAA8BX,EAAUW,6BACxCC,0BAA2BZ,EAAUY,0BACrCR,YAAaJ,EAAUI,gBAUpBpB,OAAOuF,YAAYvF,OAAO2C,QAAQsC,GAAUO,IAAI,EAAE1I,EAAM2F,MAAS,OAAC3F,GAlBjDwE,EAkBoEmB,EAjBjFzB,EAAUI,YAAY,CAAEE,cADZ,IAACA,MCtBhBmE,EAAarL,QAAQC,IAAIqL,0BACzBC,EAAYvL,QAAQC,IAAIuL,iCACxBC,EAAazL,QAAQC,IAAIyL,8BACzBC,EAAa3L,QAAQC,IAAI2L,kCAG/B,KAAKP,GAAeE,GAAcE,GAAeE,GAC/C,MAAM,IAAItB,MACR,+DAmBqBwB,EAAW,UAAUC,OAAOH,GAAYI,OAAO,OAGxE,MAAMC,EAAW,IAAIC,EAAS,CAC5B9D,SAAU,WAAWkD,6BACrBa,OAAQ,OACRjD,YAAa,CACXkD,YAAaV,EACbW,gBAAiBT,GAEnBU,iBAAkB,OAEpBtJ,QAAQmB,IACN,iBACA8H,EAAShK,OAAOmG,SAChB6D,EAAShK,OAAOiH,aCxDX,MAAMqD,EACL,CACJC,QAAS,WCSPC,EAA8C,CAClDC,aAAc,CACZC,cAAe,CACb5I,QAAQ,EACRE,SAAU,MACVJ,KAAM,MAGV+I,uBAAwB/L,EAAaC,QAAQR,QAAU,SACvDuM,iBAAiB,EACjBC,kBAAmB,QAIfC,EAA0B,CAC9BC,KAAM,KACNxG,MAAO,CACLC,aAAc,KACdwG,WAAY,KACZC,WAAY,MAEdC,iBAAiB,EACjBC,WAAW,EACX/I,MAAO,MAIHgJ,EAAc,CAACC,EAAkBC,KACrC,OAAQA,EAAOzF,MACb,IAAK,cACH,MAAO,IAAKwF,EAAOF,UAAWG,EAAOC,SAEvC,IAAK,YACH,MAAO,IAAKF,EAAOjJ,MAAOkJ,EAAOC,QAASJ,WAAW,GAEvD,IAAK,WACH,MAAO,IACFE,EACHN,KAAMO,EAAOC,QACbL,kBAAmBI,EAAOC,QAC1BnJ,MAAO,MAGX,IAAK,aACH,MAAO,IAAKiJ,EAAO9G,MAAO+G,EAAOC,SAEnC,IAAK,oBACH,MAAO,IAAKF,EAAOH,gBAAiBI,EAAOC,SAE7C,IAAK,cACH,MAAO,IACFF,EACHN,KAAMM,EAAMN,KAAO,IAAKM,EAAMN,QAASO,EAAOC,SAAY,MAG9D,IAAK,aACH,MAAO,IACFT,EACHK,WAAW,GAGf,QACE,OAAOE,IAKPG,EAAcC,OAA4C/J,GAQnDgK,EAA4C,EAAGC,WAAU3L,aACpE,MAAOqL,EAAOO,GAAYC,EAAWT,EAAaN,GAC5CgB,EAAe,IAAKtB,KAAmBxK,GAAU,CAAA,GAGjD+L,EAAcC,EAAazH,IN6JN,IAAC7D,EAAcC,EAAYC,EAA1BF,EM5JZ,QN4J0BC,EM5JjB4D,EN6JlBxE,EAAckD,QAAQvC,EAAMC,EAAOC,GAbnB,EAACF,EAAcC,EAAeC,KAC9Cb,EAAcU,IAAIC,EAAMC,EAAOC,IMhJpCqL,CAAU,OAAQ1H,GAAOC,cACzBoH,EAAS,CAAE/F,KAAM,aAAc0F,QAAShH,KACvC,IAEG2H,EAAaF,EAAaG,ILtFJ,CAACA,IAC7B9H,EAAa,SACbA,EAAa,QACb8H,OKoFEC,CAAe,KACbR,EAAS,CAAE/F,KAAM,eACjBsG,SAED,IAEGE,EAAWL,EAAY,KAC3B,MAAMzH,EAAQD,IASd,OARKC,GAAOC,eC1GK,MACnB,GAAsB,oBAAXnE,OAAwB,CACjC,MAAMiM,EAAWjM,QAAQC,UAAUgM,SACnC,OAAOA,GAAU9J,MAAM,OAAO,EAMhC,GDkGmB+J,GACVT,GAAclB,gBAGjBvK,OAAOC,SAASkM,SAAW,SAF3BnM,OAAOC,SAASmM,OAAOX,EAAanB,uBAAyB,iBAAiBtK,OAAOC,SAASoM,SAK3FnI,GACN,IAGHoI,EAAU,KACR1D,EAAYC,OAAO9D,4BAA4B0D,MAAO9I,IACpD,MAAMuE,EAAQ8H,IAOd,OANI9H,GAAOC,eACTxE,EAAO6G,QAAU,IACZ7G,EAAO6G,QACV+F,cAAe,UAAUrI,GAAOC,iBAG7BxE,IAITiJ,EAAYC,OAAO1D,0BAA0BsD,MAAO1G,IAClD,GAA0B,MAAtBA,EAAMqG,YACR,IACEyD,EAAW,OAGb,CAAE,MAAOW,GACP9L,QAAQqB,MAAM,wBAAyByK,GACvCjB,EAAS,CAAE/F,KAAM,YAAa0F,QAAS,yCACzC,CAEF,OAAOnJ,IAGT0K,KACC,IAGH,MAAMA,EAAcd,EAAYlD,UAC9B8C,EAAS,CAAE/F,KAAM,cAAe0F,SAAS,IACzCK,EAAS,CAAE/F,KAAM,YAAa0F,QAAS,OACvCtC,EAAYhK,KAAKoD,IAAsBiI,EAAkBC,SACtDwC,KAAMC,IACL,MAAMjC,EAAOiC,GAAKpF,MAAMqF,OACxBC,EAAQnC,KAEToC,MAAOC,IACNxB,EAAS,CAAE/F,KAAM,YAAa0F,QAAS6B,EAAI7E,SAAW,mBAEvD8E,QAAQ,KACPzB,EAAS,CAAE/F,KAAM,cAAe0F,SAAS,OAE5C,IAGG2B,EAAUlB,EAAajB,IAC3Ba,EAAS,CAAE/F,KAAM,WAAY0F,QAASR,KACrC,IAGgBiB,EAAY,KAC7BJ,EAAS,CAAE/F,KAAM,YAAa0F,QAAS,QACtC,IAGHoB,EAAU,KACRb,EAAajB,kBAAkBQ,IAC9B,CAACA,EAAOS,EAAajB,oBAExB,MAAMyC,EAAiC,IAClCjC,EACH6B,UACAb,WACAN,cACAwB,OAAQrB,EACRY,cACA9M,OAAQ8L,GAGV,OAAO0B,EAAChC,EAAYiC,SAAQ,CAAC9M,MAAO2M,EAAY3B,SAAGA,KAIxC+B,EAAU,IACLC,EAAWnC,GEzLvBoC,EAAanC,EAA4B,CAC7CoC,aAAa,EACbC,eAAiBnN,MACjBoN,iBAAiB,EACjBC,mBAAqBrN,QAGjB,SAAUsN,GAAYtC,SAAEA,IAC5B,MAAOkC,EAAaC,GAAkBI,GAAkB,IACjDH,EAAiBC,GAAsBE,GAAkB,GAChE,OACEV,EAACI,EAAWH,SAAQ,CAClB9M,MAAO,CACLkN,cACAC,iBACAC,kBACAC,sBACDrC,SAEAA,GAGP,CAEO,MAAMwC,EAAiB,IAAMR,EAAWC"}